# 浏览器 && 渲染

-   在浏览器地址栏输入网址，到看到页面，中间发生了什么https://zhuanlan.zhihu.com/p/106971491

1. http 请求阶段
2. http 响应阶段
3. 浏览器渲染阶段

## http 请求阶段

当输入 url 后,浏览器向服务器发起请求, 开始进入 request 请求阶段，这个阶段包括: **DNS 解析**、**TCP 协议的三次握手四次挥手**、
**HTTPS 和 HTTP**

## 浏览器渲染阶段

### DOM 树渲染

1. 浏览器拿到源代码后，在内存条中开辟出一块**栈内存**来提供执行环境

2. 同时分配一个**主线程**去一行一行的解析和执行代码(**前端 JS 是单线程的，原理是浏览器只会分配一个线程来解析代码**)

3. 解析遇到 \<link href="1.css"/>, 这时候主线程又两种选择

    1. 亲自去服务器，但这个时候浏览器就没人了，下面代码无法执行，必须得将 1.css 搬过来才能执行。(bad)
    2. 让自己朋友去服务器般 1.css, 主线程继续执行下面的代码，此时浏览器就有两个人干活了, 所以
       **当代码中遇到\<link />、\<img/>、\<script/>、\<audio/>、 \<video/> 等这些所有需要加载外部资源文件的请求后,
       都会单独开辟新的线程去加载资源文件，主线程继续向下执行**
       **(因此可以看出浏览器是多线程程序，但是它只分配了一个线程用来执行页面当中的代码，所以 js 是单线程的)**
    3. 浏览器会开辟一个新的内存空间--**等待任务队列(Task Queue)**,比如任务一交给线程 XXX 去做...

4. 主线程执行执行完最后一行代码(此时 Task Queue 并不一定全部执行完), 这个时候只是把 html 标签,也就是 DOM 结构渲染完了。
   只有 DOM 树页面是不会渲染出来的,它会到等待任务队列中看哪个任务完成了，将完成了的任务拿回到栈内存中去执行。等待任务执行完成
   再去任务队列拿下一个(因为 js 是单线程的),这即是**事件循环(Event Loop)**。

5. 等待任务队列分**宏任务（setTimeout、setInterval）**和 **微任务(promise)**,微任务优先与宏任务。

6. css 处理完后会生成 **CSSOM**, 浏览器会将 DOM 和 CSSDOM 结合起来生成**Render Tree（渲染树）**

7. 准备就绪后开始绘制: **通知电脑 GPU**，按照渲染树一点点的画。

-   在生成渲染树后其实还有连个阶段
    1. **回流(Layout)** 根据生成的渲染树，计算它们在设备视口（viewport）内的确切位置和大小，这个计算的阶段就是回流
    2. **重绘(Painting)** 根据渲染树已经回流得到几何信息，得到节点的绝对像素

总结:
**DOM 树渲染——> CSSDOM 树渲染 ——>生成 Render Tree（渲染树）——>Layout（回流）——>Painting（重绘）——>Display（GPU 展现在页面）**

前端性能优化方案(减少 http 请求次数和大小)：

1. 资源合并压缩
2. 图片懒加载
3. 音视频走流文件
